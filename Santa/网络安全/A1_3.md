## python 简易服务器制作

 `socket`

| 方法名            | 描述                                                         |
|-------------------|--------------------------------------------------------------|
| recv(bufsize[, flags]) | 接收来自对方的数据，`bufsize` 指定了接收数据的最大长度。         |
| send(data[, flags])     | 发送数据到对方，`data` 需要是字节串（bytes）。                 |
| sendall(data[, flags])  | 发送所有数据到对方，保证所有数据都被发送，即使需要分多次发送。|
| recvfrom(bufsize[, flags]) | 接收数据和发送方的地址，通常用于 UDP 协议。               |
| sendto(data, address)    | 发送数据到指定的地址，通常用于 UDP 协议。                   |
| connect(address)         | 连接到指定的地址，`address` 是一个元组，包含了远程主机的 IP 地址和端口号。 |
| bind(address)            | 绑定到本地地址，通常在服务器端使用，用于指定服务器监听的地址和端口。 |
| listen(backlog)          | 开始监听连接请求，`backlog` 指定了同时可以挂起的最大连接数。   |
| accept()                 | 接受一个新的连接，返回一个新的 `socket` 对象和客户端的地址。 |
| close()                  | 关闭连接。                                                   |
| settimeout(value)        | 设置 socket 的超时时间。                                     |
| gettimeout()             | 获取当前的超时时间。                                         |
| setsockopt(level, optname, value) | 设置 socket 的选项。                                     |
| getsockopt(level, optname[, buflen]) | 获取 socket 的选项。                                   |
| fileno()                 | 返回 socket 的文件描述符。                                   |
| dup()                    | 返回 socket 对象的一个副本。                                 |
| makefile([mode[, bufsize]]) | 返回与 socket 关联的文件对象。                             |


```
import socket

def handleRequest(client):
    buf = client.recv(2048)
    print(buf)
    msg = "HTTP/1.1 200 OK\r\n\r\n"
    msg1 = "Hello World!"
    client.send(('%s' % msg).encode())
    client.send(('%s' % msg1).encode())

if __name__ == "__main__":
    ip_port = ('0.0.0.0', 8000)
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.bind(ip_port)
    sock.listen(5)

    while True:
        conn, addr = sock.accept()
        handleRequest(conn)
        conn.close()
```
