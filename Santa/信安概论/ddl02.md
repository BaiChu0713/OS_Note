# 消息认证
## 认证的分类
  消息认证：接收方对收到的信息进行检验
  身份认证：系统对网络主体进行验证

## 消息认证
  目的：防止信息被篡改/伪造，保障信息的完整性

  消息认证模型：

  功能上分成两层：

  - 底层认证算法：产生认证符/用来认证消息的值

      - 消息加密：整个消息的密文作为认证签名
      - 消息认证码MAC：消息和密码的公开函数，产生一个固定长度的值
      - Hash函数：消息映射成定长的Hash值，Hash值为认证符

  - 上层协议 使接收方可验证消息真实性

## 消息加密

- 对称密钥模式

  A、B共享K、M

  A->B:密文C=E<sub>k</sub>(M)

  B解密:M=D<sub>k</sub>(C)=D<sub>k</sub>(E<sub>k</sub>(M))来查看M是否有意义

- 非对称密钥模式

  A、B拥有各自的公钥、私钥

  A->B:A用A私钥进行加密

  B:使用A公钥解密(验证信源方，实现不可抵赖)

  ![photo](/Photos/02.png)

加密：保证保密性，别人不能得到原始数据
消息认证：验证消息，不具备保密性，需要验证完整性

## 消息认证码MAC

经过算法产生一段信息，检查消息的完整性

MAC：利用密钥生成一个固定长度的端数据块，附加在消息的后面

 - 工作原理
  - A->B:   C=M+MAC<sub>A</sub>(MAC<sub>A</sub>=C<sub>K</sub>(M))

  - B:      (MAC<sub>B</sub>=C<sub>K</sub>(A发送的M))

  - B:      (MAC<sub>B</sub>==MAC<sub>A</sub>)?

## Hash函数

散列函数H(M):给定M输出为固定长度的散列值（消息摘要）

**碰撞**

M<sub>A</sub>->H(M<sub>A</sub>)=h<sub>1</sub>

M<sub>B</sub>->H(M<sub>B</sub>)=h<sub>1</sub>=H(M<sub>A</sub>)

优点：
1. 可以作用于任意数据块

2. 给定x，可以轻易算出H(x)

3. 给定h1，找到满足H(x)=h的x在计算上不可行**（单向性）**

4. 抗弱碰撞性：针对一个给定的输入，找到另一个不同的输入，使得它们的哈希值相同Hard(伪造签名)

5. 抗强碰撞性：在所有可能的输入中，找到任意两个不同的输入，使得它们的哈希值相同Hard（数据存储错误或检索失败）

- 工作原理
  - A->B: C=M+H(A)

  - B:H(B)

  - B: H(A)==H(B)?


## MD5算法

  Hash的例子

  Input：任意长度，512bit位单位分成块
  Output: 128bit的消息摘要

  特征：128位（16字节）的哈希值

![photo](/Photos/03.png)

# 第四章 数字签名

## 数字签名
认证机制，公钥密码算法的典型应用

用于识别签名人身份，只有信息的发送者产生

## 数字签名的意义

Hash函数和MAC可以保证完整性，但是要保证双方是否被第三方篡改，防止发生矛盾纠纷时双方作弊

作弊：A伪造一份消息声称是B发送给A

伪造：接收方利用共享密钥伪造消息认证码

## 基于公钥密码的数字签名机制

数字签名使用**私钥产生密文**，只能用对应的**公钥解密**，可以证实消息来源方

![photo](/Photos/04.png)

数字签名的5要素：(M,S,K,SIG,VER)

`Message`明文空间

`S`签名空间

`Key`密钥空间

`SIG`签名算法

`VER`验证算法

**签名方式**：
1. 直接数字签名

  只有发送方和接收方两个实体，私钥加密，公钥解密

2. 仲裁数字签名

  发送方、接收方、可信第三方
  
  发送方私钥加密，发送给第三方，第三方验证信息附上报文日期、仲裁签名，发送给接收方

## 数字签名方案的过程

1. 发送方计算H(M)（减少签名密文的长度，加快运算速度）

2. 发送方用自己的私钥计算消息的哈希值得到数字签名

3. 数字签名+消息 发送给接收方

4. 接收方计算H(M)，公钥解密

## 数字签名的功能
防冒充，鉴别身份，防篡改，防重放，防抵赖，机密性

## 数字签名的算法
### RSA
略
### DSA
